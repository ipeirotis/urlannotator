URLAnnotator architecture proposal
==================================

We will define here possible architectures for this project, with their pros and cons to enable us to choose the best one.


Core components/services:
-------------------------

- *JobPoster* - Place which creates *Job* s with their descriptions, manages accounts, their balances etc.

- *TrainingDataCollector* - component that given description collects matching samples (in this case urls). It will do this by using crowdsourcing platform like oDesk

- *DataValidator* - it is mechanism that takes given url and label that it was assigned and checks whether this label is right. It will be used on data generated by *TrainingDataCollector* and potentially to measure *classifier* performance

- *Classifier* - binary classifier which will decide whether website given by url matches description attached to this *Job*

- *BeatTheMachine* - mechanism for constant validation of classifier with some new data - using crowdsourcing


EventBus
========

We might use at this point some existing library. Currently there are some assumptions that we hope that will work.


Event
-----
**Event** contains:

- job_id (read *Think about* section later on)
- type
- data


EventListener
-------------

Every object that is listening on a bus implements **EventListener** interface (I know this is not java - name is convenient) which has:

- method *matches(event)*
- notify(event)


Important Events
----------------

Global:

- NewJobStarted
- JobFinished

Job related:

- CollectedSomeTrainingSamples
- TrainingSamplesCollection{Started/Ended} (start is to make other components prepare for taking this samples - in this case is Validator)
- ValidatedSomeSamples
- ..TODO..
- Classifier{Created/Updated}


Elements plugged into the *EventBus* (described later):

- ClassificatorFactory(or Manager?)
- SamplesCollectionManager
- SamplesValidationManager
- BeatTheMachineStartManager

and also this elements registered on all kind of events:

- BusLogger
- BusErrorReporter (to sent errors to Sentry-like service, email etc)


Think about:
------------

- Maybe we would like to set separate **EventBus** for every job? and have one global to handle creating and destroying of others. That way we wouldn't have to have dispatcher on jobs in every event listener ... but this can be achieved by subclassing class InterJobEventListener ...


Component specification
=======================

Job
---

It contains:

- title
- description
- expected cost (maybe with distribution on separate parts)
- classifier parameters (like to use Google Prediction API or anything else)
- golden data - sample urls matching description provided by job creator
- status
- progress
- amount of URLs we want to collect ?
- additional parameters ?


Sample
------

Created by *TrainingDataCollector*. It contains:

- url
- text / content of the website
- screen-shot (probably some url address to S3)

Optionally also:

- added_by - Worker
- added_on - date it was added

It is used to generate HIT in validation stage and to generate training sample for **Classifier**


SampleFactory or SampleContentGenerator
---------------------------------------

Two ways are now possible - make it a component of URLGathering stage or another EventListener ... TODO

This object (one for whole system?) given the URL will create sample. It will delegate two tasks (each can be separate job / MachineTask on Tagasauris?):

- getting content of the website
- making screen-shot of the website, uploading it somewhere (S3?), returning it url

XXX: How do we want this to do:

- in Tagasauris in the same job as in **TrainingDataCollector**
- in separate jobs on Tagasauris (each in separate or all in one)
- delegate this to some service


Classifier
----------
Class abstract with methods (sample is of class *Sample*):

- new(description, classes)
- train(samples)
- classify(sample) -> class
- classify_with_info(sample) -> json? class and probability distribution over classes etc.

Implemented with:

- Google Prediction API
- some simple test classifier? (Orange library?)


What can go wrong:
~~~~~~~~~~~~~~~~~~

- quota exceeded - we throw exception and depending on situation handle it properly. When we are at stage of collecting samples for training we should buffer them. If we are classifying for user some of his samples we will just present to him this information.
- Internal fail: like out of memory, dead service (when using Google Prediction) or just some crash due to some internal bug etc.


Classifier based on Google Prediction API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We will have to use Google Cloud Storage.
Good source of information can be found:
https://developers.google.com/prediction/docs/developer-guide
I'm still not sure if we can use long texts as samples...


ClassifierManager/Factory
-------------------------

This object is responsible for creating **Classifier** when new job is created based on its parameters. It also creates **ClassifierEventListener** and plugs it to proper event bus and just created classifier.



TagasaurisJobMonitor
--------------------

This component will be responsible for checking whether given job has finished on Tagasauris makes proper event on such situation.

Maybe there is a chance that this can also send job results as soon as they get back?
^^^^^ Currently I don't think so.

We could use MachineTask to do this - sending just processed images...




TrainingSamplesCollector
------------------------

This will use Tagasauris.
As input it takes job description and creates proper tasks using Tagasauris.



Useful small elements
----------------------

- exception QuotaLimitExceeded



Smaller components
------------------

*WorkerAction*,

Revenue
~~~~~~~
Defines how much do we pay users for their jobs.

*RevenueDefinition* is mapping from (**WorkerAction**, **result**) into **Money**?
This should be stored in some csv or json file so that it can be configured.


BeatTheMachineRevenueMechanics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Defines how much revenue will be given to worker for proving given sample. Components:

- **RevenueType** - describes whether we are satisfied with sample provided by user or not. Examples:

 - TP or TN - no error - useless sample for us
 - FP
 - FN
 - low confidence but correct

 etc

-
- RevenueDefinition - mapping from

method *reporterRevenue(classifier_difference ...)*
returns payback or



BeatTheMahine
-------------

TODO: It will be designed later on. Probably very later on...


Notes & TODO's
==============


Other Notes
-----------

- Storage for samples given to train classificator?
- Storage for samples given by Workers
- Storage for votes given to samples by Workers
- Storage for samples and their rating in BeatTheMachine
-

